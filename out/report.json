{
  "anchor_summary": {
    "topic": "Symbolic Governor in agent systems",
    "subareas": [
      "Formal verification",
      "Deterministic programming",
      "Trust in AI systems"
    ],
    "key_terms": [
      "Symbolic Governor",
      "System 2",
      "deterministic code",
      "formal verification",
      "LLM"
    ],
    "likely_venues": [
      "AI conferences",
      "Software engineering journals",
      "Formal methods workshops"
    ],
    "exclusions": [
      "Non-deterministic systems",
      "Unverified AI models",
      "General machine learning without formal methods"
    ]
  },
  "existing_citations_count": 0,
  "seed_expansion_used": false,
  "bib_path": "cases\\references.bib",
  "existing_entries_count": 10,
  "new_entries_added_count": 1,
  "new_bibkeys_added": [
    "UnknownTrustworthy"
  ],
  "warnings": [],
  "claims": [
    {
      "sid": "S0",
      "sentence": "The Symbolic Governor acts as the \"System 2\" component of the agent.",
      "rationale": "The role of the Symbolic Governor as the 'System 2' component is a specific conceptual claim that requires citation.",
      "claim_type": "definition",
      "queries": [
        "Symbolic Governor in agent systems",
        "System 2 component in AI agents",
        "formal verification of deterministic programming in AI",
        "trust in AI systems with Symbolic Governor",
        "LLM and deterministic code in agent systems"
      ],
      "selected": [],
      "status": "NEED_MANUAL",
      "notes": "No reliable BibTeX (missing DOI)."
    },
    {
      "sid": "S1",
      "sentence": "It is the root of trust.",
      "rationale": "The phrase 'It is the root of trust' makes a claim about trust without providing a source or context, necessitating citation.",
      "claim_type": "definition",
      "queries": [
        "Symbolic Governor in agent systems for formal verification",
        "Trust in AI systems through deterministic programming",
        "Formal verification methods for Symbolic Governor applications",
        "Impact of deterministic code on trust in AI systems",
        "System 2 approaches in AI with Symbolic Governor"
      ],
      "selected": [
        {
          "paper_id": null,
          "title": "Specification and Verification of Multi-Agent Systems",
          "authors": [],
          "year": null,
          "venue": null,
          "abstract": "area. We introduce modal logics used for specification of temporal, epistemic,\nand strategic properties of systems; then, we present some model checking algo-\nrithms, and discuss the computational complexity of the model checking prob-\nlem. Finally, we consider symbolic (compact) representations of systems based\non Binary Decision Diagrams (BDD) and propositional logic formulas, and show... 3. Specification of agents and their teams. Strategic logics: Coalition Logic,\nATL. Meta-properties: axiomatization, model equivalence. Reasoning about\nscenarios with imperfect information.\n4. Complexity of verification. Model checking complexity for explicit models,\ncomplexity proofs. State-space explosion. Complexity revisited: compact rep-\nresentation of transitions, higher-order representations.\n5. Practical model checking. BDD-based and SAT-based approaches to model\nchecking, bounded and unbounded model checking for CTLK, unbounded\nmodel checking for ATL.... of propositions, and each \u223c\ud456\u2286\ud446\ud461\u00d7 \ud446\ud461is an equivalence relation that defines the\nindistinguishability of states for agent \ud456. Operators K\ud456are provided with the\nusual Kripke semantics given by the clause:... \ud701: 2\ud446\ud461\u2212\u21922\ud446\ud461if\n\ud701(\ud446\ud461\u2032) = \ud446\ud461\u2032.... and time has been presented in [28]. The proposal builds on a notion of global\nstates, defined formally as follows. Firstly, each agent \ud456\u2208\ud538gt = {1, ..., \ud458} has\na set of local states \ud446\ud461\ud456. Every global state is represented by a tuple of local... interpreted systems provide more \u201cgrounded\u201d semantics for agents\u2019 knowledge\nthan abstract Kripke models. This is because starting from the local state spaces\nmakes it clearer how the epistemic model should be actually constructed.\nIt is usually assumed in interpreted systems that each agent has access only\nto its own local state, i.e.:... relatively easy. For high complexity classes, this is not the case anymore.\nThe process of verification (so called model checking) answers whether a given\nformula \ud711is satisfied in a state \ud45eof model \ud440. Formally, local model checking is\nthe decision problem that determines membership in the set",
          "doi": "10.1007/978-3-642-31485-8_6",
          "url": "https://home.ipipan.waw.pl/w.jamroga/papers/verification12esslli-lncs.pdf",
          "citation_count": null,
          "source": "perplexity",
          "seed_boost": 0.0,
          "relevance": 0.3,
          "support": 0.4,
          "authority": 0.2,
          "final": 0.33499999999999996,
          "evidence_snippet": "algorithmic verification of homogeneous dynamic multi-agent systems.",
          "why": "The paper discusses verification techniques that contribute to the trustworthiness of multi-agent systems."
        }
      ],
      "status": "NEED_MANUAL",
      "notes": "No candidates met thresholds. Provide manual review."
    },
    {
      "sid": "S2",
      "sentence": "Unlike the LLM, the Governor is implemented in deterministic code (e.",
      "rationale": "The statement compares the implementation of the Governor and LLM, which requires citation to support the claim about deterministic code.",
      "claim_type": "comparison",
      "queries": [
        "Symbolic Governor in agent systems",
        "formal verification of deterministic programming",
        "trust in AI systems with Symbolic Governor",
        "LLM vs Symbolic Governor in deterministic code",
        "formal methods for Symbolic Governor implementation"
      ],
      "selected": [],
      "status": "NEED_MANUAL",
      "notes": "No reliable BibTeX (missing DOI)."
    },
    {
      "sid": "S3",
      "sentence": "g., Python, Rust) and is formally verifiable.",
      "rationale": "The statement refers to formal verifiability, which is a factual claim that typically requires citation.",
      "claim_type": "prior_work",
      "queries": [
        "Symbolic Governor in agent systems formal verification",
        "deterministic programming with Symbolic Governor",
        "trust in AI systems using formal verification",
        "System 2 and deterministic code in AI",
        "LLM and Symbolic Governor for formal methods"
      ],
      "selected": [
        {
          "paper_id": null,
          "title": "Trustworthy AI",
          "authors": [],
          "year": null,
          "venue": null,
          "abstract": "# Computer Science > Artificial Intelligence\n\n**arXiv:2002.06276** (cs)\n\n[Submitted on 14 Feb 2020]... # Title: Trustworthy AI\nAuthors:Jeannette M. Wing\nAbstract:The promise of AI is huge. AI systems have already achieved good enough performance to be in our streets and in our homes. However, they can be brittle and unfair. For society to reap the benefits of AI systems, society needs to be able to trust them. Inspired by decades of progress in trustworthy computing, we suggest what trustworthy properties would be desired of AI systems. By enumerating a set of new research questions, we explore one approach--formal verification--for ensuring trust in AI. Trustworthy AI ups the ante on both trustworthy computing and formal methods.... |Comments:|12 pages|\n|--|--|\n|Subjects:|Artificial Intelligence (cs.AI)|\n|ACM classes:|C.4; D.3.1; D.4.6; F.3.1; G.3; I.2|\n|Cite as:|arXiv:2002.06276 [cs.AI]|... | |(or arXiv:2002.06276v1 [cs.AI] for this version)|\n| |https://doi.org/10.48550/arXiv.2002.06276 arXiv-issued DOI via DataCite|\n\n## Submission history\nFrom: Jeannette Wing [view email] **[v1]** Fri, 14 Feb 2020 22:45:36 UTC (406 KB)\n\nFull-text links:\n## Access Paper:\n- View PDF\n- Other Formats\nview license",
          "doi": "10.71265/pztsvw73",
          "url": "https://arxiv.org/abs/2002.06276",
          "citation_count": null,
          "source": "perplexity",
          "seed_boost": 0.0,
          "relevance": 0.4,
          "support": 0.3,
          "authority": 0.2,
          "final": 0.31999999999999995,
          "evidence_snippet": "formal proofs of an algorithm\u2019s optimal quality do not guarantee that an application implements or uses the algorithm correctly.",
          "why": "This paper highlights the limitations of formal proofs, which detracts from the claim about the effectiveness of formal verification."
        }
      ],
      "status": "NEED_MANUAL",
      "notes": "No candidates met thresholds. Provide manual review."
    }
  ]
}